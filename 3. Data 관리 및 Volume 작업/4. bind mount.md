# 바인드 마운트

바인드 마운트는 볼륨과 비슷한 기능을 하는 데이터 저장소이다.

* 볼륨과의 차이점

볼륨은 도커가 호스트 시스템의 특정 경로에 직접 볼륨을 만들고 도커에 의해 관리되기 때문에 사용자가 접근할 수 없다. 하지만 바인드 마운트는 사용자에 의해 관리되고 직접 접근할 수 있는 차이가 있다.
또한 바인드 마운트 된 로컬 호스트의 경로에서 소스 코드를 수정하면 컨테이너에 수정된 소스 코드가 바로 반영된다. 소스 코드를 수정하면 이미지를 다시 빌드하고 컨테이너를 실행시켜야 했지만, 실시간으로 수정한 내용을
빌드와 재시작 없이 바로 확인할 수 있는 장점이 있는 것이다.

<br/>

## 바인드 마운트 사용

```
docker run -v [local path:container path] ...
```

Volume 옵션으로 로컬 호스트의 경로와 컨테이너의 경로를 지정해준다. 

<img src="images/04/run fail.png">
위 그림에서 컨테이너의 WORKDIR 경로와 이미지를 빌드한 파일들이 담긴 프로젝트의 경로를 마운트 해주었다. -v 옵션이 2개가 들어갔는데, 바인드 마운트든 볼륨이든 여러개를 동시에 지정해줄 수 있다. 여기선 feedback이라는 이름의 볼륨과 바인드 마운트를 동시에 지정했다.

<br/>

<img src="images/04/fail logs.png">
하지만 로그를 확인해보면 express 모듈을 찾지 못해서 실패했다고 한다. 

<br/><br/>

<img src="images/04/container volume interaction.png">

위 그림의 구조를 볼 때, 볼륨의 경우 컨테이너 내부의 파일이 외부 볼륨에도 똑같이 적용되는 방식이라면, 바인드 마운트의 경우 마운트된 로컬 호스트의 파일이나 폴더를 컨테이너에 적용시키는 방식이다. 따라서, 로컬호스트에는 npm install 명령으로 종속성 패키지들을 다운받지 않아 node_moludes 폴더가 없고, 이 상태로 컨테이너에 덮어써버렸기 때문에 위의 express 모듈을 찾지 못한다는 오류가 출력된 것이다.<br/>
이 문제를 해결하려면 또 다른 볼륨으로 컨테이너의 node_modules 폴더를 지정해주어야 한다.

<br/>

<img src="images/04/run success.png">

위의 그림에선 익명 볼륨으로 node_modules 폴더를 지정해주었다. 도커는 모든 볼륨을 체크하는데, 경로상에 충돌이 있는 겨우, 항상 더 긴 내부 경로가 우선적으로 적용이 된다. 바인드 마운트는 /app 으로 최상위 경로를 지정해주었고, 익명 볼륨으로 node_modules를 따로 지정해주었기 때문에 npm install로 받은 필요한 종속성들이 삭제되지 않고 유지할 수 있게 되었다.

<br/><br/>

이제 아래와같이 로컬에서 소스 코드를 변경하면 바로 적용여부를 확인할 수 있게 되었다.
<img src="images/04/html modify.png">

<img src="images/04/html modify check.png">




